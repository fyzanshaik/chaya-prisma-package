### src\index.ts:
```
export * from "./schemas/auth";
export * from "./schemas/farmer";
export * from "./schemas/users";
export * from "./schemas/procurement";
export * from "./schemas/processingBatch";
export * from "./schemas/processingStage";
export * from "./schemas/sale";

export * from "@prisma/client";

import { PrismaClient } from "@prisma/client";
export const prisma = new PrismaClient();

```

### src\postinstall.js:
```
const { execSync } = require('child_process');
const path = require('path');

try {
  console.log('Running Prisma generate from package postinstall...');
  execSync(`npx prisma generate --schema=${path.join(__dirname, 'prisma/schema.prisma')}`, {
    stdio: 'inherit',
  });
  console.log('Prisma client generated successfully!');
} catch (error) {
  console.error('Failed to generate Prisma client:', error);
}

```

### src\schemas\auth.ts:
```
import { z } from 'zod';

export const loginSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(6, 'Password must be at least 6 characters'),
});

export const registerSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email address'),
  password: z.string().min(6, 'Password must be at least 6 characters'),
  role: z.enum(['ADMIN', 'STAFF']).default('STAFF'),
});

export type LoginInput = z.infer<typeof loginSchema>;
export type RegisterInput = z.infer<typeof registerSchema>;

```

### src\schemas\farmer.ts:
```
import { z } from 'zod';

export const farmerSchema = z.object({
  id: z.number().optional(),
  surveyNumber: z.string().optional(),
  name: z.string().min(2, 'Name must be at least 2 characters'),
  relationship: z.enum(['SELF', 'SPOUSE', 'CHILD', 'OTHER']),
  gender: z.enum(['MALE', 'FEMALE', 'OTHER']),
  community: z.string().min(1, 'Community is required'),
  aadharNumber: z.string().min(12, 'Valid Aadhar number required').max(12),
  state: z.string().min(1, 'State is required'),
  district: z.string().min(1, 'District is required'),
  mandal: z.string().min(1, 'Mandal is required'),
  village: z.string().min(1, 'Village is required'),
  panchayath: z.string().min(1, 'Panchayath is required'),
  dateOfBirth: z.string().transform(str => new Date(str)),
  age: z.number().int().min(18, 'Farmer must be at least 18 years old'),
  contactNumber: z.string().min(10, 'Valid contact number required'),
  isActive: z.boolean().default(true),
});

export const bankDetailsSchema = z.object({
  ifscCode: z.string().min(1, 'IFSC code is required'),
  bankName: z.string().min(1, 'Bank name is required'),
  branchName: z.string().min(1, 'Branch name is required'),
  accountNumber: z.string().min(1, 'Account number is required'),
  address: z.string().min(1, 'Bank address is required'),
  bankCode: z.string().min(1, 'Bank code is required'),
});

export const farmerDocumentsSchema = z.object({
  profilePicUrl: z.string().url('Valid profile picture URL required'),
  aadharDocUrl: z.string().url('Valid Aadhar document URL required'),
  bankDocUrl: z.string().url('Valid bank document URL required'),
});

export const fieldSchema = z.object({
  areaHa: z.number().positive('Area must be a positive number'),
  yieldEstimate: z.number().positive('Yield estimate must be a positive number'),
  location: z.object({
    lat: z.number(),
    lng: z.number(),
    accuracy: z.number(),
    altitude: z.number().nullable(),
    altitudeAccuracy: z.number().nullable(),
    timestamp: z.number(),
  }),
  landDocumentUrl: z.string().url('Valid land document URL required'),
});

export const createFarmerSchema = z.object({
  farmer: farmerSchema,
  bankDetails: bankDetailsSchema,
  documents: farmerDocumentsSchema,
  fields: z.array(fieldSchema).optional(),
});

export const updateFarmerSchema = z.object({
  farmer: farmerSchema.partial(),
  bankDetails: bankDetailsSchema.partial().optional(),
  documents: farmerDocumentsSchema.partial().optional(),
  fields: z.array(fieldSchema.partial()).optional(),
});

export const farmerQuerySchema = z.object({
  page: z.string().transform(Number).default('1'),
  limit: z.string().transform(Number).default('10'),
  search: z.string().optional(),
  state: z.string().optional(),
  district: z.string().optional(),
  gender: z.enum(['MALE', 'FEMALE', 'OTHER']).optional(),
  isActive: z.preprocess(val => {
    if (typeof val === 'string') {
      if (val.toLowerCase() === 'true') return true;
      if (val.toLowerCase() === 'false') return false;
    }
    return val;
  }, z.boolean().optional().default(true)),
});

export type FarmerInput = z.infer<typeof farmerSchema>;
export type BankDetailsInput = z.infer<typeof bankDetailsSchema>;
export type FarmerDocumentsInput = z.infer<typeof farmerDocumentsSchema>;
export type FieldInput = z.infer<typeof fieldSchema>;
export type CreateFarmerInput = z.infer<typeof createFarmerSchema>;
export type UpdateFarmerInput = z.infer<typeof updateFarmerSchema>;
export type FarmerQuery = z.infer<typeof farmerQuerySchema>;

```

### src\schemas\processingBatch.ts:
```
import { z } from 'zod';
import { ProcessingStageStatus } from '@prisma/client';

export const createProcessingBatchFirstStageSchema = z.object({
  processMethod: z.enum(['wet', 'dry'], { required_error: 'Process method is required' }),
  dateOfProcessing: z
    .string()
    .datetime({ message: 'Invalid datetime string. Must be UTC.' })
    .transform(str => new Date(str)),
  doneBy: z.string().min(1, 'Person responsible for P1 is required'),
});

export const createProcessingBatchSchema = z.object({
  crop: z.string().min(1, 'Crop is required'),
  lotNo: z.number().int().min(1, 'Lot number is required'),
  procurementIds: z.array(z.number().int()).min(1, 'At least one procurement must be selected'),
  firstStageDetails: createProcessingBatchFirstStageSchema,
});
export type CreateProcessingBatchInput = z.infer<typeof createProcessingBatchSchema>;

const queryStatusEnumValues: [string, ...string[]] = [
  ProcessingStageStatus.IN_PROGRESS,
  ProcessingStageStatus.FINISHED,
  ProcessingStageStatus.CANCELLED,
  'SOLD_OUT',
];

export const processingBatchQuerySchema = z.object({
  page: z.string().transform(Number).default('1'),
  limit: z.string().transform(Number).default('10'),
  search: z.string().optional(),
  status: z.enum(queryStatusEnumValues).optional(),
});
export type ProcessingBatchQuery = z.infer<typeof processingBatchQuerySchema>;

```

### src\schemas\procurement.ts:
```
import { z } from "zod";

export const createProcurementSchema = z.object({
  farmerId: z.number(),
  crop: z.string().min(1, "Crop is required"),
  procuredForm: z.string().min(1, "Procured form is required"),
  speciality: z.string().min(1, "Speciality is required"),
  quantity: z.number().positive("Quantity must be a positive number"),
  date: z.string().transform((str) => new Date(str)),
  time: z
    .string()
    .regex(/^\d{2}:\d{2}:\d{2}$/, "Invalid time format (expected HH:mm:ss)"),
  lotNo: z.number().int().min(1, "Lot number must be a positive integer"),
  procuredBy: z.string().min(1, "Procured by is required"),
  vehicleNo: z.string().min(1, "Vehicle number is required").optional(),
});

export type CreateProcurementInput = z.infer<typeof createProcurementSchema>;

export const updateProcurementSchema = createProcurementSchema
  .partial()
  .extend({
    id: z.number(),
  });
export type UpdateProcurementInput = z.infer<typeof updateProcurementSchema>;

export const procurementQuerySchema = z.object({
  page: z.string().transform(Number).default("1"),
  limit: z.string().transform(Number).default("10"),
  search: z.string().optional(),
  farmerId: z.string().transform(Number).optional(),
  crop: z.string().optional(),
  lotNo: z.string().transform(Number).optional(),
  isBatched: z.boolean().optional(),
});

export type ProcurementQuery = z.infer<typeof procurementQuerySchema>;

```

### src\schemas\users.ts:
```
import { z } from 'zod';

export const userSchema = z.object({
  id: z.number().optional(),
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email address'),
  role: z.enum(['ADMIN', 'STAFF']).default('STAFF'),
  isEnabled: z.boolean().default(true),
  isActive: z.boolean().default(false),
  lastLoginAt: z.date().nullable().optional(),
  createdAt: z.date().optional(),
  updatedAt: z.date().optional(),
});

export const updateUserSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters').optional(),
  email: z.string().email('Invalid email address').optional(),
  isEnabled: z.boolean().optional(),
  password: z.string().min(6, 'Password must be at least 6 characters').optional(),
});

export type ZodUser = z.infer<typeof userSchema>;
export type UpdateUserInput = z.infer<typeof updateUserSchema>;

```

### src\schemas\processingStage.ts:
```
import { z } from 'zod';

export const createProcessingStageSchema = z.object({
  processingBatchId: z.number().int(),
  previousStageId: z.number().int().optional(),
  processMethod: z.enum(['wet', 'dry'], { required_error: 'Process method is required' }),
  dateOfProcessing: z
    .string()
    .datetime({ message: 'Invalid datetime string. Must be UTC.' })
    .transform(str => new Date(str)),
  doneBy: z.string().min(1, 'Person responsible is required'),
});
export type CreateProcessingStageInput = z.infer<typeof createProcessingStageSchema>;

export const finalizeProcessingStageSchema = z.object({
  dateOfCompletion: z
    .string()
    .datetime({ message: 'Invalid datetime string. Must be UTC.' })
    .transform(str => new Date(str)),
  quantityAfterProcess: z.coerce
    .number({
      required_error: 'Final quantity is required',
      invalid_type_error: 'Final quantity must be a number',
    })
    .positive('Final quantity must be a positive number'),
});
export type FinalizeProcessingStageInput = z.infer<typeof finalizeProcessingStageSchema>;

export const createDryingEntrySchema = z.object({
  processingStageId: z.number().int(),
  day: z.number().int().positive('Day must be a positive integer'),
  temperature: z.number({ required_error: 'Temperature is required' }),
  humidity: z.number().min(0).max(100, 'Humidity must be between 0 and 100'),
  pH: z.number().min(0).max(14, 'pH must be between 0 and 14'),
  moisturePercentage: z.number().min(0).max(100, 'Moisture % must be between 0 and 100'),
  currentQuantity: z.coerce
    .number({
      required_error: 'Current quantity is required',
      invalid_type_error: 'Current quantity must be a number',
    })
    .positive('Current quantity after drying must be positive'),
});
export type CreateDryingEntryInput = z.infer<typeof createDryingEntrySchema>;

```

### src\schemas\sale.ts:
```
import { z } from 'zod';

export const createSaleFormSchema = z.object({
  quantitySold: z.coerce
    .number({
      required_error: 'Quantity sold is required',
      invalid_type_error: 'Quantity sold must be a number',
    })
    .positive('Quantity sold must be positive'),
  dateOfSaleInput: z.date({
    required_error: 'Date of Sale is required',
    invalid_type_error: "That's not a valid date!",
  }),
  timeOfSaleInput: z.string().regex(/^\d{2}:\d{2}:\d{2}$/, 'Invalid time format (HH:mm:ss)'),
});
export type CreateSaleFormValues = z.infer<typeof createSaleFormSchema>;

export const createSaleSchema = z.object({
  processingBatchId: z.number().int(),
  processingStageId: z.number().int(),
  quantitySold: z.coerce
    .number({
      required_error: 'Quantity sold is required',
      invalid_type_error: 'Quantity sold must be a number',
    })
    .positive('Quantity sold must be positive'),
  dateOfSale: z
    .string()
    .datetime({ message: 'Invalid datetime string. Must be UTC.' })
    .transform(str => new Date(str)),
});
export type CreateSaleInput = z.infer<typeof createSaleSchema>;

```

### package.json:
```
{
  "name": "@fyzanshaik/chaya-prisma-package",
  "version": "1.0.3",
  "description": "A shared Prisma package for database schema, types, and reusable Zod validation schemas.",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "prepublishOnly": "pnpm run db:generate && pnpm run build",
    "build": "tsc --build && pnpm db:generate",
    "dev": "tsc --watch",
    "lint": "eslint . --ext .ts,.tsx",
    "db:generate": "echo 'Running prisma generate' && prisma generate",
    "db:seed": "ts-node ./prisma/seed.ts",
    "db:migrate": "prisma migrate dev",
    "db:reset": "prisma migrate reset",
    "db:studio": "prisma studio",
    "postinstall": "node postinstall.js"
  },
  "files": [
    "dist",
    "prisma",
    ".prisma",
    "postinstall.js"
  ],
  "keywords": [
    "prisma",
    "database",
    "zod",
    "validation",
    "typescript",
    "shared package"
  ],
  "author": "Faizan Shaik ",
  "license": "ISC",
  "packageManager": "pnpm@10.5.2",
  "dependencies": {
    "@prisma/client": "6.8.2",
    "typescript": "^5.8.3",
    "zod": "^3.25.7"
  },
  "devDependencies": {
    "prisma": "^6.8.2"
  }
}
```